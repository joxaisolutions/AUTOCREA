// lib/joxcoder/relevance-client.ts

/**
 * Cliente para integrar JoxCoder (Relevance AI) en AUTOCREA
 * 
 * Este módulo maneja:
 * - Conexión con la API de Relevance AI
 * - Envío de prompts al agente JoxCoder
 * - Manejo de respuestas y errores
 * - Rate limiting y retries
 */

interface RelevanceConfig {
  apiKey: string;
  agentId: string;
  baseUrl?: string;
}

interface JoxCoderMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp?: Date;
}

interface JoxCoderResponse {
  success: boolean;
  response?: string;
  conversationId?: string;
  error?: string;
  tokensUsed?: number;
}

export class JoxCoderClient {
  private apiKey: string;
  private agentId: string;
  private baseUrl: string;
  private conversationHistory: JoxCoderMessage[] = [];

  constructor(config: RelevanceConfig) {
    this.apiKey = config.apiKey;
    this.agentId = config.agentId;
    // URL base de Relevance AI (ajusta según tu región)
    this.baseUrl = config.baseUrl || 'https://api-bcbe99.stack.tryrelevance.com/latest';
  }

  /**
   * Envía un mensaje a JoxCoder y obtiene respuesta
   * @param message - El mensaje/prompt del usuario
   * @param context - Contexto adicional (archivos, código previo, etc.)
   */
  async chat(
    message: string, 
    context?: {
      files?: Array<{ name: string; content: string }>;
      projectInfo?: string;
      conversationId?: string;
    }
  ): Promise<JoxCoderResponse> {
    try {
      // Construir el prompt con contexto
      const enrichedMessage = this.buildEnrichedMessage(message, context);

      // Agregar a historial
      this.conversationHistory.push({
        role: 'user',
        content: enrichedMessage,
        timestamp: new Date()
      });

      // Llamar a la API de Relevance
      const response = await fetch(`${this.baseUrl}/agents/${this.agentId}/trigger`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          params: {
            message: enrichedMessage,
            conversation_id: context?.conversationId || this.generateConversationId()
          },
          project: process.env.RELEVANCE_PROJECT_ID // Si lo requiere
        })
      });

      if (!response.ok) {
        throw new Error(`API Error: ${response.status} - ${response.statusText}`);
      }

      const data = await response.json();

      // Extraer la respuesta del agente
      const assistantMessage = this.extractAssistantMessage(data);

      // Agregar respuesta al historial
      this.conversationHistory.push({
        role: 'assistant',
        content: assistantMessage,
        timestamp: new Date()
      });

      return {
        success: true,
        response: assistantMessage,
        conversationId: data.conversation_id || context?.conversationId,
        tokensUsed: data.tokens_used
      };

    } catch (error) {
      console.error('JoxCoder Error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Construye un mensaje enriquecido con contexto
   */
  private buildEnrichedMessage(
    message: string, 
    context?: {
      files?: Array<{ name: string; content: string }>;
      projectInfo?: string;
    }
  ): string {
    let enrichedMessage = message;

    // Agregar información del proyecto AUTOCREA
    if (context?.projectInfo) {
      enrichedMessage = `CONTEXTO DEL PROYECTO:\n${context.projectInfo}\n\n${enrichedMessage}`;
    }

    // Agregar archivos si existen
    if (context?.files && context.files.length > 0) {
      const filesContext = context.files.map(file => 
        `\n--- ARCHIVO: ${file.name} ---\n${file.content}\n--- FIN ARCHIVO ---`
      ).join('\n');
      
      enrichedMessage = `${enrichedMessage}\n\nARCHIVOS RELEVANTES:${filesContext}`;
    }

    return enrichedMessage;
  }

  /**
   * Extrae el mensaje del asistente de la respuesta de la API
   */
  private extractAssistantMessage(data: any): string {
    // Ajusta según la estructura real de respuesta de Relevance AI
    return data.output?.answer || 
           data.output?.message || 
           data.message || 
           'No se recibió respuesta del agente';
  }

  /**
   * Genera un ID único para la conversación
   */
  private generateConversationId(): string {
    return `autocrea_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Obtiene el historial de la conversación actual
   */
  getConversationHistory(): JoxCoderMessage[] {
    return [...this.conversationHistory];
  }

  /**
   * Limpia el historial de conversación
   */
  clearHistory(): void {
    this.conversationHistory = [];
  }

  /**
   * Método helper para consultas específicas de código
   */
  async analyzeCode(
    code: string, 
    fileName: string, 
    question: string
  ): Promise<JoxCoderResponse> {
    return this.chat(prompt, {
      projectInfo: 'Proyecto AUTOCREA - Next.js 14, React 18, TypeScript, Supabase, Stripe, Vercel'
    });
  }
}

// Instancia singleton para usar en toda la aplicación
let joxCoderInstance: JoxCoderClient | null = null;

/**
 * Obtiene o crea la instancia de JoxCoder
 */
export function getJoxCoder(): JoxCoderClient {
  if (!joxCoderInstance) {
    const apiKey = process.env.RELEVANCE_API_KEY;
    const agentId = process.env.RELEVANCE_AGENT_ID;

    if (!apiKey || !agentId) {
      throw new Error(
        'Faltan credenciales de Relevance AI. ' +
        'Configura RELEVANCE_API_KEY y RELEVANCE_AGENT_ID en tus variables de entorno'
      );
    }

    joxCoderInstance = new JoxCoderClient({
      apiKey,
      agentId,
      baseUrl: process.env.RELEVANCE_BASE_URL
    });
  }

  return joxCoderInstance;
}

// Exportar tipos para usar en otros módulos
export type { JoxCoderMessage, JoxCoderResponse, RelevanceConfig };(
      `Analiza el siguiente código y responde: ${question}`,
      {
        files: [{ name: fileName, content: code }],
        projectInfo: 'Proyecto AUTOCREA - Stack: Next.js 14, Supabase, Stripe'
      }
    );
  }

  /**
   * Método helper para generar código nuevo
   */
  async generateCode(
    description: string,
    requirements: string[]
  ): Promise<JoxCoderResponse> {
    const prompt = `
Genera código para: ${description}

REQUISITOS:
${requirements.map((req, i) => `${i + 1}. ${req}`).join('\n')}

Por favor, proporciona:
1. Código completo y funcional
2. Explicación de cada parte importante
3. Consideraciones de seguridad y rendimiento
4. Instrucciones de implementación
    `.trim();

    return this.chat